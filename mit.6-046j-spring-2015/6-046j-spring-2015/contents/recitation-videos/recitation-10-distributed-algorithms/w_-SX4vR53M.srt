1
00:00:00,080 --> 00:00:02,500
The following content is
provided under a Creative

2
00:00:02,500 --> 00:00:04,019
Commons license.

3
00:00:04,019 --> 00:00:06,360
Your support will help
MIT OpenCourseWare

4
00:00:06,360 --> 00:00:10,730
continue to offer high-quality
educational resources for free.

5
00:00:10,730 --> 00:00:13,350
To make a donation or
view additional materials

6
00:00:13,350 --> 00:00:17,217
from hundreds of MIT courses,
visit MIT OpenCourseWare

7
00:00:17,217 --> 00:00:17,842
at ocw.mit.edu.

8
00:00:21,257 --> 00:00:22,090
LING REN: All right.

9
00:00:22,090 --> 00:00:24,030
Let's get started.

10
00:00:24,030 --> 00:00:28,250
Today's topic would be
distributed algorithms.

11
00:00:28,250 --> 00:00:31,900
We will look at
two new algorithms.

12
00:00:31,900 --> 00:00:35,210
But they are similar to what
you have seen in the lectures.

13
00:00:35,210 --> 00:00:38,930
So it will also be a review
of some concepts in lectures.

14
00:00:52,250 --> 00:00:56,130
So our first example
would be, again,

15
00:00:56,130 --> 00:00:59,390
[INAUDIBLE], the
simplest example.

16
00:01:05,670 --> 00:01:11,730
But this time, the network
and topology would be a ring.

17
00:01:21,810 --> 00:01:25,700
So in the lectures,
the example we see

18
00:01:25,700 --> 00:01:28,570
is a click, meaning they
are fully connected.

19
00:01:28,570 --> 00:01:29,070
Right.

20
00:01:29,070 --> 00:01:32,340
Every node can talk
to every other node.

21
00:01:32,340 --> 00:01:36,240
There, if you remember,
our solution for everyone

22
00:01:36,240 --> 00:01:39,100
to generate a UID
or a random number.

23
00:01:39,100 --> 00:01:45,260
And if you are the maximum, then
you output, you're the leader

24
00:01:45,260 --> 00:01:48,610
You can do that because, yeah,
you are connected to everybody.

25
00:01:48,610 --> 00:01:52,000
So you immediately know
what random number everybody

26
00:01:52,000 --> 00:01:52,640
generates.

27
00:01:52,640 --> 00:01:55,870
And you can compare whether
you are the largest.

28
00:01:55,870 --> 00:02:00,830
Now, the idea is the
same if we have a ring.

29
00:02:00,830 --> 00:02:04,940
So you want everyone to
generate a ID or random number.

30
00:02:04,940 --> 00:02:07,550
I'll just say ID from now on.

31
00:02:07,550 --> 00:02:11,780
And you want to collect
everyone else ID

32
00:02:11,780 --> 00:02:13,840
so that you know
whether your ID is

33
00:02:13,840 --> 00:02:18,326
the largest among all of them.

34
00:02:18,326 --> 00:02:18,826
OK.

35
00:02:24,754 --> 00:02:28,212
AUDIENCE: [INAUDIBLE]

36
00:02:29,480 --> 00:02:30,188
LING REN: Pardon?

37
00:02:30,188 --> 00:02:33,152
AUDIENCE: [INAUDIBLE]

38
00:02:34,289 --> 00:02:34,830
LING REN: OK.

39
00:02:34,830 --> 00:02:39,270
The question is where did
the comparison happen?

40
00:02:39,270 --> 00:02:42,200
So we first need
some way to pass

41
00:02:42,200 --> 00:02:44,810
the numbers around
such that everyone

42
00:02:44,810 --> 00:02:47,370
has everyone else's number.

43
00:02:47,370 --> 00:02:47,870
Right.

44
00:02:47,870 --> 00:02:49,460
You have the number
of everyone, then

45
00:02:49,460 --> 00:02:52,791
you can compare whether
the largest equals yours.

46
00:02:52,791 --> 00:02:53,290
OK.

47
00:02:53,290 --> 00:02:55,000
If the largest equals
yours, then you

48
00:02:55,000 --> 00:02:56,041
know you are the largest.

49
00:02:56,041 --> 00:03:01,130
And you're going to
output, I'm the leader.

50
00:03:01,130 --> 00:03:01,630
OK.

51
00:03:01,630 --> 00:03:05,300
So the difficulty is just
how to pass the numbers

52
00:03:05,300 --> 00:03:08,220
around so that everyone
sees everyone else's number.

53
00:03:11,120 --> 00:03:12,790
Any ideas?

54
00:03:12,790 --> 00:03:13,520
Simple solution.

55
00:03:39,755 --> 00:03:41,590
Well, there's not
much you can do.

56
00:03:41,590 --> 00:03:43,990
You are just connect to your
two neighbors, the left one

57
00:03:43,990 --> 00:03:44,740
and the right one.

58
00:03:54,800 --> 00:03:56,835
So how do you propagate
the information?

59
00:04:06,134 --> 00:04:07,130
Go ahead.

60
00:04:07,130 --> 00:04:10,616
AUDIENCE: You can take
the maximum of your ID

61
00:04:10,616 --> 00:04:14,579
and neighbor's IDs and
kind of broadcast that.

62
00:04:14,579 --> 00:04:15,120
LING REN: OK.

63
00:04:15,120 --> 00:04:16,519
So what does
broadcast mean here?

64
00:04:16,519 --> 00:04:17,935
AUDIENCE: Like
tell your neighbors

65
00:04:17,935 --> 00:04:21,720
what the largest of
your value [INAUDIBLE]

66
00:04:21,720 --> 00:04:23,230
LING REN: OK.

67
00:04:23,230 --> 00:04:25,170
And yes.

68
00:04:25,170 --> 00:04:32,650
Let me call them A, B, C, E,
F. Then, yes, C can tell D

69
00:04:32,650 --> 00:04:35,167
or can tell B, but
how does C tell E?

70
00:04:41,498 --> 00:04:47,267
AUDIENCE: It waited around to
I guess propagate the maximum.

71
00:04:47,267 --> 00:04:47,850
LING REN: Yep.

72
00:04:47,850 --> 00:04:53,970
So it would be just,
say, everyone talks

73
00:04:53,970 --> 00:04:55,660
to its right neighbor.

74
00:04:55,660 --> 00:04:58,930
And then B has A's IDs, C
these B's ID, D has C's ID,

75
00:04:58,930 --> 00:05:02,360
and then continue and
pass around next time.

76
00:05:05,390 --> 00:05:08,260
So just to make
it perfect clear.

77
00:05:08,260 --> 00:05:15,280
Say they generate some
random IDs that's 5, 10, 20.

78
00:05:15,280 --> 00:05:19,035
And then in the next round,
A would send its ID to B, B

79
00:05:19,035 --> 00:05:22,470
would send its ID to C,
C would send its ID to D.

80
00:05:22,470 --> 00:05:25,520
And in the next round, B would
pass this information along

81
00:05:25,520 --> 00:05:28,930
to C. And C would pass
the information to D.

82
00:05:28,930 --> 00:05:31,320
And just continue.

83
00:05:31,320 --> 00:05:36,240
And eventually everyone will
have everyone else's ID.

84
00:05:36,240 --> 00:05:38,720
So how many rounds do we need?

85
00:05:51,790 --> 00:05:58,001
If they are in
nodes in the system.

86
00:05:58,001 --> 00:06:00,292
AUDIENCE: I think probably
in just one direction or two

87
00:06:00,292 --> 00:06:02,110
neighbors.

88
00:06:02,110 --> 00:06:05,190
LING REN: I think you
can do it either way.

89
00:06:05,190 --> 00:06:09,914
If you propagate both ways,
it probably 2x faster, yeah.

90
00:06:09,914 --> 00:06:11,390
AUDIENCE: [INAUDIBLE]

91
00:06:11,390 --> 00:06:12,870
LING REN: Yeah, correct.

92
00:06:12,870 --> 00:06:14,700
It's just O(n).

93
00:06:14,700 --> 00:06:16,810
But to keep it simple,
let's say we just

94
00:06:16,810 --> 00:06:18,240
propagate in one direction.

95
00:06:18,240 --> 00:06:19,030
That's also fine.

96
00:06:19,030 --> 00:06:21,340
Still O(n).

97
00:06:21,340 --> 00:06:25,983
So how many messages
are sent in total?

98
00:06:25,983 --> 00:06:28,388
AUDIENCE: n squared.

99
00:06:28,388 --> 00:06:29,487
LING REN: Pardon?

100
00:06:29,487 --> 00:06:30,320
AUDIENCE: n squared.

101
00:06:30,320 --> 00:06:31,399
LING REN: n squared.

102
00:06:31,399 --> 00:06:31,898
Yep.

103
00:06:34,590 --> 00:06:37,660
Is that obvious to everyone?

104
00:06:37,660 --> 00:06:38,160
OK.

105
00:06:38,160 --> 00:06:40,132
Give an explanation.

106
00:06:40,132 --> 00:06:41,715
AUDIENCE: Yeah, at
each round everyone

107
00:06:41,715 --> 00:06:44,900
sends a message
to its neighbors.

108
00:06:44,900 --> 00:06:45,900
LING REN: Yeah.

109
00:06:45,900 --> 00:06:48,030
Yeah.

110
00:06:48,030 --> 00:06:50,350
Every round, everyone
sends a message.

111
00:06:50,350 --> 00:06:54,550
Or you can think of every
message as propagated n times.

112
00:06:54,550 --> 00:06:58,700
And there are n
messages in total.

113
00:06:58,700 --> 00:07:00,171
OK.

114
00:07:00,171 --> 00:07:00,670
Yeah.

115
00:07:00,670 --> 00:07:04,180
That's definitely a solution.

116
00:07:04,180 --> 00:07:07,000
Well, you can imagine, it's
probably the naive solution.

117
00:07:07,000 --> 00:07:09,220
And can we do better than that?

118
00:07:14,566 --> 00:07:16,996
AUDIENCE: In this case,
are we assuming they

119
00:07:16,996 --> 00:07:18,454
know that there are n of them?

120
00:07:21,380 --> 00:07:22,280
LING REN: OK.

121
00:07:22,280 --> 00:07:23,370
Good question.

122
00:07:23,370 --> 00:07:25,989
So if they know
there are n of them,

123
00:07:25,989 --> 00:07:27,530
yep, then they know
how to terminate.

124
00:07:27,530 --> 00:07:30,230
So your question is how
to terminate, right?

125
00:07:30,230 --> 00:07:35,070
If they don't, eventually
you will receive your own ID

126
00:07:35,070 --> 00:07:36,230
on the other side.

127
00:07:36,230 --> 00:07:38,850
If we keep sending
left, eventually you

128
00:07:38,850 --> 00:07:40,600
will receive it
on the left port.

129
00:07:40,600 --> 00:07:44,265
And, yeah, that's an
indication of termination.

130
00:07:47,498 --> 00:07:47,998
Question?

131
00:07:47,998 --> 00:07:49,664
AUDIENCE: Are we
assuming the trajectory

132
00:07:49,664 --> 00:07:51,165
that these are unique?

133
00:07:51,165 --> 00:07:51,790
LING REN: Yeah.

134
00:07:51,790 --> 00:07:55,480
We usually assume that, yeah.

135
00:07:55,480 --> 00:08:00,420
Either it's a unique
user-- sorry, UID.

136
00:08:00,420 --> 00:08:02,260
What does U stand
for by the way?

137
00:08:02,260 --> 00:08:06,630
Or if you generate random
numbers in a large range,

138
00:08:06,630 --> 00:08:08,180
it's very unlikely
that they collide.

139
00:08:20,560 --> 00:08:21,230
OK.

140
00:08:21,230 --> 00:08:22,480
So can we do better than that?

141
00:08:37,990 --> 00:08:40,700
You have some idea?

142
00:08:40,700 --> 00:08:47,560
AUDIENCE: Once
something [INAUDIBLE]

143
00:08:47,560 --> 00:08:52,204
where you only pass it
to the one that's bigger.

144
00:08:52,204 --> 00:08:52,870
LING REN: Hm-mm.

145
00:08:52,870 --> 00:08:53,200
OK.

146
00:08:53,200 --> 00:08:54,490
I think you have two ideas.

147
00:08:54,490 --> 00:08:58,080
And binary search, we'll
see how that works later.

148
00:08:58,080 --> 00:09:01,250
So you said only forward
something that's larger?

149
00:09:01,250 --> 00:09:02,580
0

150
00:09:02,580 --> 00:09:04,746
AUDIENCE: Yeah, like only
forward things are larger.

151
00:09:08,014 --> 00:09:09,930
LING REN: OK, yeah,
that's on the right track.

152
00:09:09,930 --> 00:09:13,730
So one obvious
thing we can do is

153
00:09:13,730 --> 00:09:18,920
that so we actually don't care
what all the IDs are, right.

154
00:09:18,920 --> 00:09:23,100
We only care whether a
certain ID's the largest.

155
00:09:23,100 --> 00:09:29,060
So for example, in this case,
when A send its ID 5 to B,

156
00:09:29,060 --> 00:09:32,210
B knows this 5
won't be the leader.

157
00:09:32,210 --> 00:09:32,710
All right.

158
00:09:32,710 --> 00:09:33,970
Because 5 is too small.

159
00:09:33,970 --> 00:09:36,220
It's even smaller than his ID.

160
00:09:36,220 --> 00:09:40,190
So we can choose to
drop this message.

161
00:09:40,190 --> 00:09:44,720
There's no point in passing
that message further.

162
00:09:44,720 --> 00:09:46,810
Same thing for this message.

163
00:09:46,810 --> 00:09:49,420
C knows that 10 is too small.

164
00:09:49,420 --> 00:09:53,980
And it doesn't have
to pass it along.

165
00:09:53,980 --> 00:09:57,452
AUDIENCE: [INAUDIBLE]

166
00:09:58,940 --> 00:09:59,940
LING REN: Oh, the ID?

167
00:09:59,940 --> 00:10:03,460
It's just the integer each
node chooses at random.

168
00:10:03,460 --> 00:10:06,210
See.

169
00:10:06,210 --> 00:10:10,280
Yeah, the only purpose of
the ID is to break symmetry.

170
00:10:10,280 --> 00:10:11,720
So, yeah.

171
00:10:11,720 --> 00:10:14,230
Like we have seen the lecture,
if they don't do this,

172
00:10:14,230 --> 00:10:17,284
if they don't have
any unique identifier,

173
00:10:17,284 --> 00:10:18,950
they won't be able
to select the leader.

174
00:10:21,570 --> 00:10:25,120
And when they have
a unique number,

175
00:10:25,120 --> 00:10:28,100
then they can select, yeah,
the largest one or smallest

176
00:10:28,100 --> 00:10:30,210
one in some way.

177
00:10:34,490 --> 00:10:34,990
OK.

178
00:10:34,990 --> 00:10:37,190
Does this optimization
make sense?

179
00:10:37,190 --> 00:10:42,650
We can cut [INAUDIBLE]
messages that

180
00:10:42,650 --> 00:10:47,365
have no chance of
becoming the leader.

181
00:10:47,365 --> 00:10:49,031
AUDIENCE: What is the
upper bound of it?

182
00:10:49,031 --> 00:10:51,310
Is it still n squared?

183
00:10:51,310 --> 00:10:52,060
LING REN: Correct.

184
00:10:52,060 --> 00:10:52,559
Yeah.

185
00:10:52,559 --> 00:10:57,300
That's a very good question and
very good answer, by the way.

186
00:10:57,300 --> 00:11:00,660
But how effective is this?

187
00:11:00,660 --> 00:11:04,510
Well in average case, we may
be able to drop some messages.

188
00:11:04,510 --> 00:11:08,190
But there pathological
case where it actually

189
00:11:08,190 --> 00:11:09,270
doesn't help at all.

190
00:11:09,270 --> 00:11:12,530
Say this is the ID we choose.

191
00:11:12,530 --> 00:11:15,450
Then when there's
20, it send around.

192
00:11:15,450 --> 00:11:17,180
B cannot drop it.

193
00:11:17,180 --> 00:11:20,320
Right, because it
may be the largest.

194
00:11:20,320 --> 00:11:23,240
And when this 10 is sent
to C, C cannot drop it.

195
00:11:23,240 --> 00:11:26,130
And when 20 comes along,
it also cannot drop it.

196
00:11:26,130 --> 00:11:30,420
So no node can drop any message.

197
00:11:30,420 --> 00:11:32,585
Its worst case is
still n square.

198
00:11:51,770 --> 00:11:52,270
OK.

199
00:11:52,270 --> 00:11:58,320
So let's think about the
binary search equivalent, yeah,

200
00:11:58,320 --> 00:12:00,240
or how to binary
search in this case.

201
00:12:07,968 --> 00:12:11,130
AUDIENCE: So binary
is [INAUDIBLE] what?

202
00:12:11,130 --> 00:12:12,380
LING REN: Yeah, good question.

203
00:12:12,380 --> 00:12:15,920
It's not very obvious
binary searching to what.

204
00:12:18,800 --> 00:12:23,530
I Yeah, just some
binary idea that

205
00:12:23,530 --> 00:12:26,510
will give us a n log end bound.

206
00:12:26,510 --> 00:12:29,640
So actually this is
the better logarithm.

207
00:12:29,640 --> 00:12:31,982
But once you have a
log n, you can probably

208
00:12:31,982 --> 00:12:32,773
get-- OK, go ahead.

209
00:12:32,773 --> 00:12:35,360
AUDIENCE: How about
kind of merging,

210
00:12:35,360 --> 00:12:39,019
like instead of finding
the [INAUDIBLE],

211
00:12:39,019 --> 00:12:43,355
finding like log maximum,
then [INAUDIBLE].

212
00:12:43,355 --> 00:12:43,980
LING REN: Yeah.

213
00:12:43,980 --> 00:12:46,448
That's on the right track, yeah.

214
00:12:46,448 --> 00:12:48,281
AUDIENCE: Like clusters
of some [INAUDIBLE].

215
00:12:50,615 --> 00:12:51,240
LING REN: Yeah.

216
00:12:51,240 --> 00:12:55,440
That's definitely
the right idea.

217
00:12:55,440 --> 00:12:58,411
Let's detail it a little bit.

218
00:12:58,411 --> 00:12:59,410
How do you carry it out?

219
00:13:16,274 --> 00:13:17,266
Hm-mm.

220
00:13:17,266 --> 00:13:19,746
AUDIENCE: Divide the two parts.

221
00:13:24,210 --> 00:13:27,170
Like kind of the [INAUDIBLE].

222
00:13:27,170 --> 00:13:29,440
LING REN: And, OK,
so then it's let

223
00:13:29,440 --> 00:13:33,940
them select their leader
respectively and compare

224
00:13:33,940 --> 00:13:35,710
which one is larger.

225
00:13:35,710 --> 00:13:37,590
It's interesting thought.

226
00:13:48,975 --> 00:13:50,955
AUDIENCE: First,
for example, A, B

227
00:13:50,955 --> 00:13:53,430
finds the maximum
between these two,

228
00:13:53,430 --> 00:13:57,885
the C, D finds the maximum
E [INAUDIBLE] maximum.

229
00:13:57,885 --> 00:14:00,855
Kind of merging, considering
them as one node.

230
00:14:02,877 --> 00:14:04,460
LING REN: I think
the first difficulty

231
00:14:04,460 --> 00:14:06,870
I see is that if
you cut it by half,

232
00:14:06,870 --> 00:14:09,157
it's no longer a ring, right.

233
00:14:13,149 --> 00:14:17,150
AUDIENCE: Also they can't
cut themselves in half.

234
00:14:17,150 --> 00:14:17,830
LING REN: Yeah.

235
00:14:17,830 --> 00:14:18,190
Yeah.

236
00:14:18,190 --> 00:14:18,700
Correct.

237
00:14:18,700 --> 00:14:20,000
Yeah, yeah.

238
00:14:43,952 --> 00:14:48,532
Yeah, it's definitely
not an easy problem, not

239
00:14:48,532 --> 00:14:49,240
a easy algorithm.

240
00:14:54,370 --> 00:15:01,330
And the idea is to, well,
you had the right idea.

241
00:15:01,330 --> 00:15:07,380
That we want to--
what's the word?

242
00:15:07,380 --> 00:15:10,030
Let the weak candidates
shut up early.

243
00:15:12,630 --> 00:15:17,790
So what I mean by that is say
we have several round, so this B

244
00:15:17,790 --> 00:15:25,690
and A and C. We will that B
only propagate to A and C first.

245
00:15:25,690 --> 00:15:30,600
If B is the local maximum
among A, B, C, then

246
00:15:30,600 --> 00:15:32,390
B will try to talk further.

247
00:15:35,000 --> 00:15:36,430
Increase its range.

248
00:15:36,430 --> 00:15:40,140
If B is not the local maximum
of A, B, C, then, yeah,

249
00:15:40,140 --> 00:15:41,600
it can be quiet.

250
00:15:41,600 --> 00:15:44,460
Doesn't need to send
messages anymore.

251
00:15:44,460 --> 00:15:46,550
If B succeeds in the
next round, then you

252
00:15:46,550 --> 00:15:51,320
go further increase its range
to try to talk to more people.

253
00:15:55,670 --> 00:15:56,310
OK.

254
00:15:56,310 --> 00:15:58,010
So how does it work in detail?

255
00:16:00,910 --> 00:16:07,950
Well so in round I,
we will let a node

256
00:16:07,950 --> 00:16:12,950
send this message up
to 2 raised to I hops.

257
00:16:16,190 --> 00:16:20,485
In this case, is 1 and in
next round is 2 and then 4.

258
00:16:24,090 --> 00:16:29,460
If at any point some mode
like along this range

259
00:16:29,460 --> 00:16:32,940
decides that you are
not the local maximum,

260
00:16:32,940 --> 00:16:37,790
then they will reply
that, yeah, you no longer

261
00:16:37,790 --> 00:16:40,600
need to send messages anymore.

262
00:16:40,600 --> 00:16:45,360
If this message successfully
reaches this endpoint

263
00:16:45,360 --> 00:16:48,980
that 2 raised to I hops,
then this guy will respond.

264
00:16:48,980 --> 00:16:52,890
And this guy, if it still thinks
you are the local maximum,

265
00:16:52,890 --> 00:16:57,520
then it will respond the message
while saying, yeah, continue.

266
00:17:03,250 --> 00:17:03,750
OK.

267
00:17:03,750 --> 00:17:11,190
And if the sender receives the
continue message on both sides,

268
00:17:11,190 --> 00:17:14,190
then they it continue
into the next round.

269
00:17:14,190 --> 00:17:16,063
Otherwise, it will go inactive.

270
00:17:20,272 --> 00:17:21,230
Is the algorithm clear?

271
00:17:35,581 --> 00:17:37,664
AUDIENCE: If the problem
reaches the next maximum,

272
00:17:37,664 --> 00:17:41,729
like next the node each
has to send a message.

273
00:17:41,729 --> 00:17:42,770
LING REN: Say that again.

274
00:17:42,770 --> 00:17:47,180
AUDIENCE: Like after receiving
like don't sending it,

275
00:17:47,180 --> 00:17:49,262
like do you have to
choose one node, which

276
00:17:49,262 --> 00:17:50,542
has to send the message?

277
00:17:50,542 --> 00:17:51,250
LING REN: Oh, OK.

278
00:17:51,250 --> 00:17:54,110
In the first round, everyone
send their messages.

279
00:17:54,110 --> 00:17:54,610
OK.

280
00:17:54,610 --> 00:17:57,820
Then some of them
will go inactive

281
00:17:57,820 --> 00:17:59,930
because they learn
they are not maximum.

282
00:17:59,930 --> 00:18:02,630
And the remaining,
the surviving ones,

283
00:18:02,630 --> 00:18:05,350
will, yeah, continue
sending messages.

284
00:18:05,350 --> 00:18:07,410
And then, yeah, half
of them probably

285
00:18:07,410 --> 00:18:08,911
will die in the next round.

286
00:18:08,911 --> 00:18:10,785
And the surviving ones
keep sending messages.

287
00:18:14,315 --> 00:18:14,815
Make sense?

288
00:18:21,038 --> 00:18:23,483
AUDIENCE: How do you
return messages through I?

289
00:18:23,483 --> 00:18:26,906
Like if you [INAUDIBLE] its
neighbor and not the node that

290
00:18:26,906 --> 00:18:28,276
do either.

291
00:18:28,276 --> 00:18:28,900
LING REN: Yeah.

292
00:18:28,900 --> 00:18:32,340
So we will send the
message of this form,

293
00:18:32,340 --> 00:18:35,970
say, well, some message.

294
00:18:39,200 --> 00:18:43,970
And then we will send the
hop and the direction,

295
00:18:43,970 --> 00:18:47,260
either left or right.

296
00:18:47,260 --> 00:18:50,160
And this hop will
initially be set

297
00:18:50,160 --> 00:18:56,150
to 2 raised to I,
the number of round.

298
00:18:56,150 --> 00:18:58,505
Then when this guy
receives the message,

299
00:18:58,505 --> 00:19:05,420
it will increment the hop
count and pass it along.

300
00:19:05,420 --> 00:19:08,170
And every node when
forwarding the message

301
00:19:08,170 --> 00:19:12,220
will decrease the that h by 1.

302
00:19:12,220 --> 00:19:16,490
And finally when it reaches
here, that number becomes 0.

303
00:19:16,490 --> 00:19:23,020
And when a node sees a
message with 0 hop count,

304
00:19:23,020 --> 00:19:26,220
it's going to reverse it, send
it in the other direction.

305
00:19:26,220 --> 00:19:36,220
And, again, set it
back to 2 raised to I.

306
00:19:36,220 --> 00:19:41,040
This message I should say ID.

307
00:19:44,770 --> 00:19:48,780
And at certain
point, a certain node

308
00:19:48,780 --> 00:19:50,920
may decide this ID's too small.

309
00:19:50,920 --> 00:19:52,300
It doesn't have a chance.

310
00:19:52,300 --> 00:19:56,710
Then the I can directly send
it in the opposite direction,

311
00:19:56,710 --> 00:19:58,974
replying a message saying,
yeah, you are too small.

312
00:20:02,610 --> 00:20:03,290
OK.

313
00:20:03,290 --> 00:20:09,200
So any more questions
on the algorithm itself?

314
00:20:09,200 --> 00:20:11,090
If not, what's the next step?

315
00:20:16,425 --> 00:20:17,395
AUDIENCE: Time.

316
00:20:17,395 --> 00:20:19,030
LING REN: Yeah, time complexity.

317
00:20:19,030 --> 00:20:21,210
I already claimed it's n log n.

318
00:20:21,210 --> 00:20:21,800
Is it?

319
00:20:27,800 --> 00:20:30,194
This is round.

320
00:20:30,194 --> 00:20:30,860
This is message.

321
00:20:33,900 --> 00:20:35,270
This is also message complexity.

322
00:20:38,820 --> 00:20:39,320
OK.

323
00:20:39,320 --> 00:20:40,345
So why is it n log n?

324
00:21:15,190 --> 00:21:18,034
AUDIENCE: The log n [INAUDIBLE].

325
00:21:18,034 --> 00:21:18,700
LING REN: Hm-mm.

326
00:21:18,700 --> 00:21:22,055
So we have a certain
number of rounds.

327
00:21:22,055 --> 00:21:23,305
So how many rounds do we have?

328
00:21:28,530 --> 00:21:31,010
AUDIENCE: Two.

329
00:21:31,010 --> 00:21:32,000
LING REN: Yeah, maybe.

330
00:21:32,000 --> 00:21:33,936
But, yeah, I'll just say log n.

331
00:21:33,936 --> 00:21:34,436
OK.

332
00:21:37,280 --> 00:21:42,810
Because you are increasing
your hop length.

333
00:21:42,810 --> 00:21:48,250
And we're going to compute
like how many nodes are still

334
00:21:48,250 --> 00:21:55,490
active each around and how many
messages are sent in the round.

335
00:21:55,490 --> 00:22:02,630
So, well, the number
of nodes active

336
00:22:02,630 --> 00:22:07,651
will just be this number
if we start from 0.

337
00:22:07,651 --> 00:22:08,150
Why?

338
00:22:08,150 --> 00:22:11,210
Because the first time
everyone is active.

339
00:22:11,210 --> 00:22:16,210
In the next time, only 1/3
of them will be active.

340
00:22:16,210 --> 00:22:20,100
But we said we are conservative
here at we put 1/2.

341
00:22:20,100 --> 00:22:21,080
Right.

342
00:22:21,080 --> 00:22:23,490
Next round is actually 1/5.

343
00:22:27,180 --> 00:22:29,350
If it's local maximum,
it means like these two

344
00:22:29,350 --> 00:22:32,625
and those two will go inactive.

345
00:22:32,625 --> 00:22:39,200
But we put this
as a upper bound.

346
00:22:39,200 --> 00:22:44,660
So this is the number of
nodes that are still active.

347
00:22:44,660 --> 00:22:52,890
And they will send the
message up to this many hops.

348
00:22:56,285 --> 00:22:58,710
OK.

349
00:22:58,710 --> 00:23:00,955
And there are two directions.

350
00:23:06,460 --> 00:23:08,400
And you send a message back.

351
00:23:08,400 --> 00:23:11,760
And then, yeah-- sorry,
send the message forward

352
00:23:11,760 --> 00:23:15,175
and someone will reply.

353
00:23:15,175 --> 00:23:18,615
But in the end, this is n log n.

354
00:23:24,117 --> 00:23:28,500
Yeah, and I think
I got 8n log n.

355
00:23:28,500 --> 00:23:32,664
So my recitation note says
it's 4 log n, not entirely sure

356
00:23:32,664 --> 00:23:33,330
what's going on.

357
00:23:33,330 --> 00:23:33,830
Yeah.

358
00:23:33,830 --> 00:23:36,330
But you can double check
whether this is correct

359
00:23:36,330 --> 00:23:38,170
or the recitation
note is correct.

360
00:23:58,728 --> 00:24:01,190
AUDIENCE: What is I again?

361
00:24:01,190 --> 00:24:04,790
LING REN: I's the number
of round in the I-th round.

362
00:24:04,790 --> 00:24:05,290
Yeah.

363
00:24:05,290 --> 00:24:07,230
This many nodes
are still active.

364
00:24:07,230 --> 00:24:11,020
And each of them will send
a message of this many hops.

365
00:24:28,090 --> 00:24:30,970
And I didn't mention
whether the network

366
00:24:30,970 --> 00:24:32,680
is synchronous or asynchronous.

367
00:24:32,680 --> 00:24:35,180
And it turns out
it doesn't care.

368
00:24:35,180 --> 00:24:38,680
Some of them can work for both
synchronous and asynchronous.

369
00:24:38,680 --> 00:24:40,960
Apparently, it works for
synchronous networks.

370
00:24:40,960 --> 00:24:45,710
If it's asynchronous,
then what changes

371
00:24:45,710 --> 00:24:49,620
is that different nodes
are in different rounds.

372
00:24:49,620 --> 00:24:52,650
A certain node may be far
ahead than the others.

373
00:24:52,650 --> 00:24:53,590
But it's fine.

374
00:24:53,590 --> 00:24:59,660
Eventually, they will converge
to the correct result. OK.

375
00:24:59,660 --> 00:25:01,505
So let's look at
the second problem.

376
00:25:07,330 --> 00:25:10,070
Well, problem's
defined even simpler.

377
00:25:10,070 --> 00:25:15,140
We just want to count how
many nodes are out there.

378
00:25:15,140 --> 00:25:19,235
We want the algorithm to
work both synchronously and

379
00:25:19,235 --> 00:25:19,860
asynchronously.

380
00:25:23,560 --> 00:25:26,260
By that I just mean
we have a network.

381
00:25:33,130 --> 00:25:36,220
Well, say you have a
lot of nodes after that.

382
00:25:36,220 --> 00:25:39,440
Just want to count how
many nodes are there

383
00:25:39,440 --> 00:25:40,170
in this network.

384
00:25:45,440 --> 00:25:49,312
So I'll give you, say, one
minutes to let's first come up

385
00:25:49,312 --> 00:25:50,270
with a high-level plan.

386
00:25:56,350 --> 00:25:58,543
Is the problem clear?

387
00:25:58,543 --> 00:26:02,471
AUDIENCE: In the worst
case, [INAUDIBLE].

388
00:26:02,471 --> 00:26:05,389
The worst case.

389
00:26:05,389 --> 00:26:05,930
LING REN: OK.

390
00:26:05,930 --> 00:26:06,888
I haven't defined that.

391
00:26:06,888 --> 00:26:11,460
Let's not worry about
complexity now for now.

392
00:26:11,460 --> 00:26:14,380
The complexity will
depend on number of nodes

393
00:26:14,380 --> 00:26:22,330
and the number of
edges, E. Let's just

394
00:26:22,330 --> 00:26:23,610
get it functionally correct.

395
00:27:53,070 --> 00:27:53,630
OK.

396
00:27:53,630 --> 00:27:56,090
Anyone share a
high-level strategy?

397
00:28:01,130 --> 00:28:01,820
Go ahead.

398
00:28:01,820 --> 00:28:05,257
AUDIENCE: So each
node will start

399
00:28:05,257 --> 00:28:11,149
like IDs of the other
devices [INAUDIBLE].

400
00:28:11,149 --> 00:28:15,077
So basically like it's going
to send propagates [INAUDIBLE]

401
00:28:15,077 --> 00:28:18,023
sets of each node.

402
00:28:23,424 --> 00:28:25,310
LING REN: On what edge?

403
00:28:25,310 --> 00:28:26,495
AUDIENCE: Furthest one.

404
00:28:26,495 --> 00:28:27,120
LING REN: Yeah.

405
00:28:27,120 --> 00:28:30,274
It wasn't on both edges?

406
00:28:30,274 --> 00:28:32,409
AUDIENCE: Itself first.

407
00:28:32,409 --> 00:28:32,950
LING REN: OK.

408
00:28:32,950 --> 00:28:38,030
So then maybe send the 1 here
and send the 1 here there.

409
00:28:38,030 --> 00:28:41,870
Then this node will think it
has a children, it as a child,

410
00:28:41,870 --> 00:28:43,060
right, which is this one.

411
00:28:43,060 --> 00:28:46,430
Let's just say this
is the entire network.

412
00:28:46,430 --> 00:28:50,772
And what message does
it send to this guy?

413
00:28:50,772 --> 00:28:51,772
AUDIENCE: Reinforced it.

414
00:28:57,450 --> 00:28:59,440
LING REN: Well, you
probably need send two here

415
00:28:59,440 --> 00:29:04,480
because you have one and this
is possibly its child, right.

416
00:29:04,480 --> 00:29:06,484
But then we're double
counting this node.

417
00:29:06,484 --> 00:29:07,150
See the problem?

418
00:29:13,442 --> 00:29:16,589
AUDIENCE: Do nodes have
their IDs, like unique IDs?

419
00:29:16,589 --> 00:29:17,380
LING REN: Oh, yeah.

420
00:29:17,380 --> 00:29:18,460
They have their IDs.

421
00:29:18,460 --> 00:29:20,680
AUDIENCE: We can't send
the IDs instead of the IDs

422
00:29:20,680 --> 00:29:22,589
through the end node.

423
00:29:22,589 --> 00:29:23,130
LING REN: OK.

424
00:29:26,300 --> 00:29:29,103
We are going to
send all the IDs.

425
00:29:29,103 --> 00:29:30,186
AUDIENCE: Yeah, neighbors.

426
00:29:43,497 --> 00:29:49,269
And after n steps, it's going
to have the [INAUDIBLE].

427
00:29:49,269 --> 00:29:49,810
LING REN: OK.

428
00:29:49,810 --> 00:29:51,550
Yeah, that's an
interesting thought.

429
00:29:51,550 --> 00:29:56,260
And then you may
still need the root.

430
00:29:56,260 --> 00:30:01,750
And that will have
everyone's ID.

431
00:30:01,750 --> 00:30:04,710
And then see how many
unique I's are there.

432
00:30:07,600 --> 00:30:08,100
OK.

433
00:30:08,100 --> 00:30:09,060
Interesting.

434
00:30:09,060 --> 00:30:12,455
Does this algorithm work?

435
00:30:12,455 --> 00:30:13,790
Yeah, I don't see any problem.

436
00:30:22,376 --> 00:30:23,810
OK.

437
00:30:23,810 --> 00:30:28,650
But let me still repeat
what our algorithm

438
00:30:28,650 --> 00:30:34,900
is because it's closer
to what's in the lecture.

439
00:30:34,900 --> 00:30:42,305
So we're going to find a
spanning tree of this network.

440
00:30:44,960 --> 00:30:47,720
A spanning tree
means, well, like I

441
00:30:47,720 --> 00:30:49,135
have to cut one of these edges.

442
00:30:52,840 --> 00:30:56,860
If I have a tree, then I
can have every child report

443
00:30:56,860 --> 00:30:58,610
to its parent.

444
00:30:58,610 --> 00:31:05,130
Like how many offsprings,
including myself do I have.

445
00:31:05,130 --> 00:31:11,510
And this node will sum
up all its children

446
00:31:11,510 --> 00:31:12,670
and report to its parent.

447
00:31:18,370 --> 00:31:20,440
Does everyone get that?

448
00:31:20,440 --> 00:31:23,550
So first, we'll find
a spanning tree.

449
00:31:29,466 --> 00:31:37,154
And second, we'll have
child reports to parent.

450
00:31:50,790 --> 00:31:54,470
AUDIENCE: How can we
find the spanning tree?

451
00:31:54,470 --> 00:31:55,470
LING REN: Good question.

452
00:31:55,470 --> 00:31:59,770
So in the lecture, we
have seen algorithm

453
00:31:59,770 --> 00:32:12,105
that find BFS spanning tree
for synchronous networks.

454
00:32:15,330 --> 00:32:15,830
OK.

455
00:32:15,830 --> 00:32:17,380
This is review of the lecture.

456
00:32:20,732 --> 00:32:21,440
How does it work?

457
00:32:35,290 --> 00:32:39,280
Each node will, say, we
need to first choose a root.

458
00:32:39,280 --> 00:32:43,350
And our root will just send
a message to its neighbor

459
00:32:43,350 --> 00:32:46,950
and, yeah, saying, you are
my child, you are my child,

460
00:32:46,950 --> 00:32:49,000
you are my child.

461
00:32:49,000 --> 00:32:53,300
And then every node upon
receiving this message

462
00:32:53,300 --> 00:33:00,724
from the parent will
search among its neighbors.

463
00:33:00,724 --> 00:33:01,690
All right.

464
00:33:01,690 --> 00:33:04,260
So the neighbors that
haven't got a parent

465
00:33:04,260 --> 00:33:08,515
will acknowledge this
sender as the parent.

466
00:33:12,400 --> 00:33:12,900
OK.

467
00:33:12,900 --> 00:33:13,910
That's a little messy.

468
00:33:27,650 --> 00:33:33,380
So this node will
search to the leaf node.

469
00:33:33,380 --> 00:33:36,250
But then it will also try
to search for this guy.

470
00:33:36,250 --> 00:33:38,630
But this guy already had
a parent, then, yeah,

471
00:33:38,630 --> 00:33:44,210
it will say I already got a
parent and blah, blah, blah.

472
00:33:44,210 --> 00:33:47,330
This will give us a
BFS spanning tree.

473
00:33:47,330 --> 00:33:48,080
What does it mean?

474
00:33:48,080 --> 00:33:50,075
It's a spanning
tree found by BFS.

475
00:33:52,620 --> 00:33:54,680
Does it work for
asynchronous network?

476
00:33:59,680 --> 00:34:00,395
Go ahead.

477
00:34:00,395 --> 00:34:01,172
AUDIENCE: This version doesn't.

478
00:34:01,172 --> 00:34:02,672
But there's a
different version that

479
00:34:02,672 --> 00:34:05,110
contains an edge for
relaxation technique.

480
00:34:05,110 --> 00:34:05,840
LING REN: Yeah.

481
00:34:05,840 --> 00:34:06,470
Correct.

482
00:34:06,470 --> 00:34:10,931
And so why does this version not
work for a synchronous network?

483
00:34:10,931 --> 00:34:12,306
AUDIENCE: Because
different nodes

484
00:34:12,306 --> 00:34:14,290
can be on a different
round number

485
00:34:14,290 --> 00:34:18,270
so that a longer path could
end up going to the node even.

486
00:34:18,270 --> 00:34:19,290
LING REN: Yeah, exactly.

487
00:34:19,290 --> 00:34:23,030
So let me give a
concrete example.

488
00:34:23,030 --> 00:34:25,080
What does asynchronous
network mean?

489
00:34:25,080 --> 00:34:28,580
Is that, well, messages
travel at different speed.

490
00:34:28,580 --> 00:34:32,760
Say this link for some
reason is temporarily down.

491
00:34:32,760 --> 00:34:37,030
And this node doesn't receive
the message from the root.

492
00:34:37,030 --> 00:34:41,210
And then this message
travels very fast.

493
00:34:41,210 --> 00:34:43,000
And this message also
travels very fast.

494
00:34:43,000 --> 00:34:47,480
So this message may
reach this node earlier.

495
00:34:47,480 --> 00:34:52,300
And then this node will think
of it as a child of this node.

496
00:34:52,300 --> 00:34:52,850
OK.

497
00:34:52,850 --> 00:34:55,889
And then this message
comes along, finally.

498
00:34:55,889 --> 00:34:58,490
But this node says, yeah,
I already have a parent.

499
00:34:58,490 --> 00:35:00,870
And I'm going to reject you.

500
00:35:00,870 --> 00:35:03,070
AUDIENCE: So it still
makes a spanning tree?

501
00:35:03,070 --> 00:35:04,220
LING REN: Yes.

502
00:35:04,220 --> 00:35:05,330
Good point.

503
00:35:05,330 --> 00:35:09,143
This is not a BFS spanning tree
but it's still a spanning tree.

504
00:35:09,143 --> 00:35:09,870
All right.

505
00:35:09,870 --> 00:35:12,600
So in our problem, we're
totally fine with it.

506
00:35:16,340 --> 00:35:16,840
Yeah.

507
00:35:16,840 --> 00:35:20,210
But you do have to know if
you really want a BFS spanning

508
00:35:20,210 --> 00:35:22,580
tree in an asynchronous
network, then

509
00:35:22,580 --> 00:35:25,002
you have to like record the
distance and do the relaxation

510
00:35:25,002 --> 00:35:25,960
and so on and so forth.

511
00:35:29,229 --> 00:35:30,170
OK.

512
00:35:30,170 --> 00:35:33,740
So we will just use this
algorithm, the BFS spanning

513
00:35:33,740 --> 00:35:37,139
tree algorithm, just
run it asynchronously.

514
00:35:37,139 --> 00:35:38,680
It doesn't find the
BFS spanning tree

515
00:35:38,680 --> 00:35:40,610
but it finds some spanning tree.

516
00:35:46,990 --> 00:35:47,490
OK.

517
00:35:47,490 --> 00:35:48,850
How does this algorithm work?

518
00:35:56,290 --> 00:35:58,030
We will have several variables.

519
00:35:58,030 --> 00:36:01,510
The first one is parent.

520
00:36:01,510 --> 00:36:04,540
We will initialize to
this undefined single.

521
00:36:13,900 --> 00:36:14,900
OK.

522
00:36:14,900 --> 00:36:20,350
Then every node will pass
around this search message.

523
00:36:20,350 --> 00:36:23,170
I'll use a slightly
more shorthand notation

524
00:36:23,170 --> 00:36:24,185
than from the lecture.

525
00:36:32,746 --> 00:36:33,250
OK.

526
00:36:33,250 --> 00:36:38,920
Let's say the code I
wrote is for a process u.

527
00:36:42,392 --> 00:36:44,880
OK.

528
00:36:44,880 --> 00:36:51,410
If we receive a message,
a search message, from v

529
00:36:51,410 --> 00:37:01,135
to u, that means u-- sorry, v
is trying to become a parent.

530
00:37:01,135 --> 00:37:01,635
OK.

531
00:37:05,130 --> 00:37:11,530
And if I do not
have a parent yet,

532
00:37:11,530 --> 00:37:25,310
I should set the
parent to v. OK.

533
00:37:25,310 --> 00:37:26,432
So what's the next step?

534
00:37:38,990 --> 00:37:41,120
Now, we got this search
message from our parent.

535
00:37:41,120 --> 00:37:43,200
And we have to pass it along.

536
00:37:49,687 --> 00:37:52,431
AUDIENCE: Should we
send it to the like

537
00:37:52,431 --> 00:37:53,690
add your child [INAUDIBLE].

538
00:37:53,690 --> 00:37:54,830
LING REN: Oh, yeah.

539
00:37:54,830 --> 00:37:55,330
Great.

540
00:37:58,746 --> 00:38:03,310
Yeah, we first need to
respond by saying, OK,

541
00:38:03,310 --> 00:38:07,300
I'll use a shorter notation.

542
00:38:07,300 --> 00:38:12,860
Send these a cue that
that's the message that will

543
00:38:12,860 --> 00:38:14,640
be sent to v at some point.

544
00:38:17,350 --> 00:38:21,330
The message we send is parent 1.

545
00:38:21,330 --> 00:38:23,640
Parent 2.

546
00:38:23,640 --> 00:38:30,107
This is a response to v saying,
yeah, you are my parent.

547
00:38:34,400 --> 00:38:34,990
OK.

548
00:38:34,990 --> 00:38:50,720
Then else, we also have to
respond by saying parent 0.

549
00:38:50,720 --> 00:38:54,820
You are not my parent because I
already got some other parent.

550
00:38:54,820 --> 00:38:55,320
OK.

551
00:38:55,320 --> 00:38:56,474
Missing a step here.

552
00:39:03,590 --> 00:39:05,255
If we receive a search message.

553
00:39:05,255 --> 00:39:06,500
Go ahead.

554
00:39:06,500 --> 00:39:08,935
AUDIENCE: We send messages
to all the other nodes.

555
00:39:08,935 --> 00:39:09,560
LING REN: Yeah.

556
00:39:09,560 --> 00:39:17,170
We need to pass it to all
my potential children.

557
00:39:17,170 --> 00:39:26,050
So I use this comma u,
meaning the neighbors of u.

558
00:39:26,050 --> 00:39:27,870
And then I'll send
them a message.

559
00:39:31,959 --> 00:39:32,500
What message?

560
00:39:35,410 --> 00:39:35,910
Search.

561
00:39:47,041 --> 00:39:47,540
OK.

562
00:39:59,465 --> 00:39:59,965
OK.

563
00:39:59,965 --> 00:40:06,000
So, well, naturally since
we have a search message

564
00:40:06,000 --> 00:40:08,130
and we know how to
deal with it, now we

565
00:40:08,130 --> 00:40:10,620
are sending this parent message
with better deal with it.

566
00:40:10,620 --> 00:40:11,940
Right.

567
00:40:11,940 --> 00:40:15,940
So then the next
chunk of code should

568
00:40:15,940 --> 00:40:25,030
be if we receive this parent
message, I'll say parent b,

569
00:40:25,030 --> 00:40:28,540
meaning this message comes
with either true or false.

570
00:40:32,590 --> 00:40:37,854
I received this message
from some node w.

571
00:40:37,854 --> 00:40:38,700
OK.

572
00:40:38,700 --> 00:40:40,780
I'm still u here.

573
00:40:40,780 --> 00:40:43,910
Because I just send all
the message to all the w's,

574
00:40:43,910 --> 00:40:46,765
to all my neighbors, and they
should give me a response.

575
00:40:55,430 --> 00:40:55,930
OK.

576
00:40:55,930 --> 00:41:03,530
If b is 1 that means
this particular w

577
00:41:03,530 --> 00:41:06,810
take me as its parent.

578
00:41:06,810 --> 00:41:09,360
Make sense?

579
00:41:09,360 --> 00:41:10,210
OK.

580
00:41:10,210 --> 00:41:14,280
So I'd better have a
list of my children.

581
00:41:14,280 --> 00:41:16,500
I want to keep track of that.

582
00:41:16,500 --> 00:41:17,000
How?

583
00:41:20,320 --> 00:41:25,480
We will create a new
variable for children.

584
00:41:25,480 --> 00:41:28,890
It's going to be
initialized to what?

585
00:41:32,100 --> 00:41:33,190
Yeah, empty set.

586
00:41:37,730 --> 00:41:42,040
And now if this b
is 1, then I'm going

587
00:41:42,040 --> 00:41:45,182
to put w in this children list.

588
00:41:49,910 --> 00:41:51,170
OK.

589
00:41:51,170 --> 00:42:01,700
I'm leaving some space
here because our root

590
00:42:01,700 --> 00:42:03,020
should be slightly different.

591
00:42:03,020 --> 00:42:06,050
So every other node will
send search messages

592
00:42:06,050 --> 00:42:07,954
when it receive
a search message.

593
00:42:07,954 --> 00:42:09,120
We need someone to initiate.

594
00:42:12,260 --> 00:42:14,130
Make sense?

595
00:42:14,130 --> 00:42:20,800
So if u equals root,
we say the root is v0.

596
00:42:26,460 --> 00:42:28,300
So two things should happen.

597
00:42:28,300 --> 00:42:34,260
First, we should set its
parent to some special value.

598
00:42:34,260 --> 00:42:35,150
Just say root.

599
00:42:40,050 --> 00:42:44,527
And then I should copy
this blob of code to here.

600
00:42:58,163 --> 00:42:59,160
OK.

601
00:42:59,160 --> 00:43:04,720
It's a little crowded but
I hope it's still legible.

602
00:43:14,930 --> 00:43:15,430
OK.

603
00:43:15,430 --> 00:43:19,050
This is already almost
the correct algorithm,

604
00:43:19,050 --> 00:43:22,020
except that we don't
know how to terminate.

605
00:43:22,020 --> 00:43:24,720
If we wait long
enough, then everyone

606
00:43:24,720 --> 00:43:29,110
will receive all the responses
and everyone will know

607
00:43:29,110 --> 00:43:32,721
its parent and this child list.

608
00:43:32,721 --> 00:43:33,720
But how do we terminate?

609
00:43:38,322 --> 00:43:39,472
AUDIENCE: After n rounds.

610
00:43:39,472 --> 00:43:41,680
LING REN: Yeah, that's one
way to do, after n rounds.

611
00:43:41,680 --> 00:43:44,710
But the whole point is we
are trying to find what n is.

612
00:43:44,710 --> 00:43:46,420
We don't know how
many nodes are there.

613
00:43:46,420 --> 00:43:50,920
AUDIENCE: If we receive
reject for all, [INAUDIBLE].

614
00:43:53,920 --> 00:43:55,551
LING REN: Say again.

615
00:43:55,551 --> 00:44:00,999
AUDIENCE: For all the search,
if we receive a reject.

616
00:44:00,999 --> 00:44:01,790
LING REN: Oh, yeah.

617
00:44:01,790 --> 00:44:06,850
If you receive a response,
either parent 0 or parent 1

618
00:44:06,850 --> 00:44:11,370
from all your neighbors, then
your job is pretty much done.

619
00:44:11,370 --> 00:44:14,813
But the others have not.

620
00:44:14,813 --> 00:44:15,760
All right.

621
00:44:15,760 --> 00:44:17,700
So you send a message very fast.

622
00:44:17,700 --> 00:44:18,920
They responded to you.

623
00:44:18,920 --> 00:44:22,930
And they are still
working very hard.

624
00:44:22,930 --> 00:44:23,630
OK.

625
00:44:23,630 --> 00:44:27,490
So then we need to use the
technique from the lecture

626
00:44:27,490 --> 00:44:31,050
that's called converge cast.

627
00:44:31,050 --> 00:44:36,430
So everyone will send a
done signal when it is done

628
00:44:36,430 --> 00:44:38,016
and all its children
are also done.

629
00:44:41,404 --> 00:44:41,904
OK.

630
00:44:44,830 --> 00:44:50,150
To do that, I'm going to define
a new variable called searched.

631
00:44:50,150 --> 00:44:53,816
Searched means
someone has responded.

632
00:44:53,816 --> 00:44:54,750
OK.

633
00:44:54,750 --> 00:44:58,670
In this case, w has responded.

634
00:44:58,670 --> 00:45:01,070
I'll put it into
the search the list,

635
00:45:01,070 --> 00:45:05,001
no matter whether it accepts
me as parent or reject.

636
00:45:05,001 --> 00:45:05,500
OK.

637
00:45:05,500 --> 00:45:09,230
Then naturally I need to
define this variable here.

638
00:45:24,699 --> 00:45:25,200
OK.

639
00:45:25,200 --> 00:45:38,310
As a last step, If we search the
list equals my neighbor list,

640
00:45:38,310 --> 00:45:43,660
that means everyone
has responded

641
00:45:43,660 --> 00:45:51,630
and all my children
are done, then

642
00:45:51,630 --> 00:45:55,410
I need a new
variable called done.

643
00:45:55,410 --> 00:46:03,388
That's another list tracking who
has finished and who has not.

644
00:46:07,628 --> 00:46:08,128
OK.

645
00:46:08,128 --> 00:46:09,600
AUDIENCE: So what's
the first one?

646
00:46:09,600 --> 00:46:10,530
LING REN: Say again.

647
00:46:10,530 --> 00:46:11,930
AUDIENCE: What
was the first one?

648
00:46:11,930 --> 00:46:13,140
LING REN: This one?

649
00:46:13,140 --> 00:46:16,975
Searched means
someone has responded

650
00:46:16,975 --> 00:46:18,961
to the search message.

651
00:46:18,961 --> 00:46:19,460
OK.

652
00:46:19,460 --> 00:46:25,170
Done means all its
children are done.

653
00:46:25,170 --> 00:46:27,975
I haven't write how
done is defined.

654
00:46:27,975 --> 00:46:29,130
Give me a minute.

655
00:46:29,130 --> 00:46:34,780
In this case, I'm going to
send my parent a message.

656
00:46:34,780 --> 00:46:38,460
This is the step
of converge cast.

657
00:46:38,460 --> 00:46:39,257
What do I send?

658
00:46:39,257 --> 00:46:40,590
I'm going to send them I'm done.

659
00:46:48,318 --> 00:46:49,780
OK.

660
00:46:49,780 --> 00:46:52,620
Then whenever we
create a message,

661
00:46:52,620 --> 00:46:56,440
we should deal
with that message.

662
00:46:56,440 --> 00:47:02,821
If we receive a message
I'm done, what do we do?

663
00:47:02,821 --> 00:47:03,320
OK.

664
00:47:03,320 --> 00:47:11,480
From w, then we're going
to mark that node as done.

665
00:47:26,030 --> 00:47:26,830
OK.

666
00:47:26,830 --> 00:47:28,470
There's this other point.

667
00:47:28,470 --> 00:47:32,450
So someone has to
initiate the done signal.

668
00:47:32,450 --> 00:47:34,550
That's going to be
our leaves, right.

669
00:47:34,550 --> 00:47:37,160
Because when this
condition check,

670
00:47:37,160 --> 00:47:38,510
they don't have any children.

671
00:47:38,510 --> 00:47:40,130
Their children
list is empty set.

672
00:47:40,130 --> 00:47:42,270
And their done list
is also empty set.

673
00:47:42,270 --> 00:47:45,580
But they're going to send
the I'm done signal first.

674
00:47:45,580 --> 00:47:47,740
And then in the
median nodes, we'll

675
00:47:47,740 --> 00:47:52,281
send a done signal when
all its children are done.

676
00:47:52,281 --> 00:47:52,780
All right.

677
00:47:52,780 --> 00:47:57,150
So this is the
converged cast version.

678
00:47:57,150 --> 00:48:00,930
Only gives us a
termination point

679
00:48:00,930 --> 00:48:04,380
of our spanning tree search.

680
00:48:04,380 --> 00:48:08,090
We haven't count the number
of nodes in the network.

681
00:48:11,072 --> 00:48:15,330
But that's a small modification.

682
00:48:15,330 --> 00:48:19,700
We're just going to include that
number in the I'm done signal.

683
00:48:19,700 --> 00:48:24,190
So then I need to define
another variable called

684
00:48:24,190 --> 00:48:27,460
total that's initialized to 0.

685
00:48:27,460 --> 00:48:31,040
This variable will
attract how many

686
00:48:31,040 --> 00:48:35,560
nodes do I have in
my subtree, including

687
00:48:35,560 --> 00:48:36,720
me and all my children.

688
00:48:39,740 --> 00:48:43,040
Then when I send
the I'm done signal,

689
00:48:43,040 --> 00:48:47,370
I'm going to send this-- sorry.

690
00:48:47,370 --> 00:48:50,700
That's not right way.

691
00:48:50,700 --> 00:48:52,790
When I'm sending
the I'm done signal,

692
00:48:52,790 --> 00:48:57,980
I'm going to send my total
number of offspring with it.

693
00:48:57,980 --> 00:49:03,330
And when I receive,
one of my children

694
00:49:03,330 --> 00:49:05,110
reports that I do
have t children.

695
00:49:08,310 --> 00:49:12,070
I need to increment my
total by that amount.

696
00:49:21,601 --> 00:49:22,100
OK.

697
00:49:22,100 --> 00:49:24,240
I made a mistake again.

698
00:49:24,240 --> 00:49:28,060
Should be total plus 1.

699
00:49:28,060 --> 00:49:29,010
Right.

700
00:49:29,010 --> 00:49:30,930
Because I'm counting
all my children and then

701
00:49:30,930 --> 00:49:32,030
I should include myself.

702
00:49:43,426 --> 00:49:44,800
So that's the
complete algorithm.

703
00:49:49,370 --> 00:49:49,870
Yeah.

704
00:49:49,870 --> 00:49:53,970
One purpose is just to create
a different angle to look

705
00:49:53,970 --> 00:49:55,070
at distributed algorithm.

706
00:49:55,070 --> 00:49:58,310
Usually just draw
that network graphs.

707
00:49:58,310 --> 00:50:00,980
But sometimes it's
helpful to think about how

708
00:50:00,980 --> 00:50:02,227
the code actually works.

709
00:50:05,703 --> 00:50:06,203
OK.

710
00:50:10,180 --> 00:50:12,170
That's all for today.